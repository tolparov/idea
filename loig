package ru.sber.poirot.dictionaries.notifier

import org.springframework.beans.factory.annotation.Value
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.stereotype.Service
import ru.sber.poirot.exception.FrontException
import ru.sber.toJson
import ru.sber.utils.logger

@Service
@ConditionalOnProperty("spring.kafka.producer.enable", havingValue = "true", matchIfMissing = false)
class KafkaDictionariesNotifier(
    private val kafkaTemplate: KafkaTemplate<String, String>,
    @Value("\${spring.kafka.topic:}")
    private val topic: String
) : DictionariesUpdateNotifier {
    private val log = logger()

    override suspend fun notify(dictName: String) {
        log.info("Sending to kafka dictionary update event for={}", dictName)
        try {
            DictionaryUpdateEvent(dictName = dictName).send()
        } catch (exception: Exception) {
            exception.printStackTrace()
            throw FrontException("–ù–µ —É–¥–∞–ª–æ—Å—å —Å—Ä–∞–∑—É –æ–±–Ω–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∞ –≤ –∫—ç—à–∞—Ö, –ø–æ–¥–æ–∂–¥–∏—Ç–µ –ø—Ä–∏–º–µ—Ä–Ω–æ 10 –º–∏–Ω—É—Ç")
        }
    }

    private suspend fun DictionaryUpdateEvent.send() {
        kafkaTemplate.send(topic, this@send.toJson())
    }
} 
//
package ru.sber.poirot.dictionaries.notifier

import com.fasterxml.jackson.annotation.JsonProperty
import java.time.LocalDateTime
import java.time.LocalDateTime.now
import java.util.UUID.randomUUID

class DictionaryUpdateEvent(
    val uuid: String = randomUUID().toString(),
    val eventDt: LocalDateTime = now(),
    @JsonProperty("triggerName")
    val dictName: String
)—ç—Ç–æ –ø—Ä–∏–º–µ—Ä –∫–∞–∫ –∑–∞–ø–æ–ª–Ω—è–µ—Ç—Å—è –æ–±—à–∏–π —Ç–æ–ø–∏–∫ INTERNAL.CACHE_UPDATES. –í–æ—Ç –º–æ–π —Ç–µ–∫—É—â–∏–π –∫–æ–¥. –ö–∞–∂–¥—ã–π —Ñ–∞–π–ª –±—É–¥—É —Ä–∞–∑–¥–µ–ª—è—Ç—å –≤ –Ω–∞—á–∞–ª –¥–≤—É–º—è —Å–ª—ç—à–∞–º–∏ 
//
package ru.sber.poirot.notifications.websocket

import org.springframework.web.reactive.socket.WebSocketSession
import reactor.core.publisher.FluxSink
import ru.sber.poirot.notifications.admin.dto.FeedResponse
import ru.sber.utils.logger
import java.time.LocalDateTime
import java.util.concurrent.ConcurrentHashMap

object BroadcastRegistry {

    private val log = logger()
    private val clients = ConcurrentHashMap<String, ConnectedClient>()

    data class ConnectedClient(
        val session: WebSocketSession,
        val roleIds: Set<Int>,
        val feed: MutableList<FeedResponse>,
        val sink: FluxSink<List<FeedResponse>>
    )

    fun register(
        sessionId: String,
        session: WebSocketSession,
        roleIds: Set<Int>,
        initialFeed: MutableList<FeedResponse>,
        sink: FluxSink<List<FeedResponse>>
    ) {
        clients[sessionId] = ConnectedClient(session, roleIds, initialFeed, sink)
        log.info("‚úÖ Registered session: {}, roleIds: {}, total clients: {}",
            sessionId, roleIds, clients.size)
        sink.onDispose { clients.remove(sessionId) }
    }

    fun unregister(sessionId: String) {
        clients.remove(sessionId)
        log.info("‚ùå Unregistered session: {}, remaining clients: {}", sessionId, clients.size)
    }

    fun publish(feedResponses: List<FeedResponse>) {
        log.info("üì¢ Broadcasting {} notifications to {} clients",
            feedResponses.size, clients.size)

        cleanupDeadSessions()

        feedResponses.forEach { feed ->
            clients.values.forEach { client ->
                try {
                    processUpdate(client, feed)
                } catch (e: Exception) {
                    log.error("‚ùå Error processing update for session {}: {}",
                        client.session.id, e.message, e)
                    unregister(client.session.id)
                }
            }
        }
    }

    fun removeNotification(notificationId: Long) {
        log.info("üóëÔ∏èRemoving notification {} from {} clients",
            notificationId, clients.size)

        cleanupDeadSessions()

        clients.values.toList().forEach { client ->
            try {
                // –£–¥–∞–ª—è–µ–º –∏–∑ feed –∫–ª–∏–µ–Ω—Ç–∞
                val removed = client.feed.removeIf { it.id == notificationId }

                if (removed) {
                    log.debug("üì® Removed notification {} from client {}",
                        notificationId, client.session.id)

                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫
                    sendThroughSink(client)
                }
            } catch (e: Exception) {
                log.error("‚ùå Error removing notification from client {}: {}",
                    client.session.id, e.message, e)
                unregister(client.session.id)
            }
        }
    }

    fun refreshAll() {
        log.info("üîÑ [{}] Refreshing all connected clients", clients.size)

        cleanupDeadSessions()

        clients.values.toList().forEach { client ->
            try {
                sendThroughSink(client)
            } catch (e: Exception) {
                log.error("‚ùå Error refreshing client {}: {}",
                    client.session.id, e.message, e)
                unregister(client.session.id)
            }
        }
    }

    fun hasExpiredNotifications(): Boolean {
        val now = LocalDateTime.now()
        return clients.values.any { client ->
            client.feed.any { feed ->
                now.isAfter(feed.dateTo) || now.isBefore(feed.dateFrom)
            }
        }
    }

    private fun cleanupDeadSessions() {
        val deadSessions = clients.filter { !it.value.session.isOpen }
        if (deadSessions.isNotEmpty()) {
            log.warn("üßπ Cleaning up {} dead sessions", deadSessions.size)
            deadSessions.forEach { (sessionId, _) ->
                unregister(sessionId)
            }
        }
    }

    private fun processUpdate(client: ConnectedClient, feed: FeedResponse) {
        val existingIndex = client.feed.indexOfFirst { it.id == feed.id }
        val shouldShow = shouldShowNotification(client, feed)

        when {
            !shouldShow && existingIndex != -1 -> {
                client.feed.removeAt(existingIndex)
                log.debug("‚ùå Removed notification {} from client {}",
                    feed.id, client.session.id)
            }
            shouldShow && existingIndex == -1 -> {
                client.feed.add(feed)
                log.debug("‚ûï Added notification {} to client {}",
                    feed.id, client.session.id)
            }
            shouldShow && existingIndex != -1 -> {
                client.feed[existingIndex] = feed
                log.debug("üîÑ Updated notification {} for client {}",
                    feed.id, client.session.id)
            }
        }
        sendThroughSink(client)
    }

    private fun shouldShowNotification(client: ConnectedClient, feed: FeedResponse): Boolean {
        val now = LocalDateTime.now()
        return !feed.archived &&
                feed.publish &&
                hasRole(client, feed) &&
                !now.isBefore(feed.dateFrom) &&
                !now.isAfter(feed.dateTo)
    }

    private fun hasRole(client: ConnectedClient, feed: FeedResponse): Boolean {
        return feed.roleIds.isEmpty() || client.roleIds.any { it in feed.roleIds }
    }

    private fun sendThroughSink(client: ConnectedClient) {
        try {
            if (!client.session.isOpen) {
                log.warn("‚ö†Ô∏è Session {} is closed, unregistering", client.session.id)
                unregister(client.session.id)
                return
            }

            val activeMessages = client.feed.filter { feed ->
                shouldShowNotification(client, feed)
            }

            log.debug("üì® Emitting {} notifications to session {} via sink",
                activeMessages.size, client.session.id)

            client.sink.next(activeMessages)

        } catch (e: Exception) {
            log.error("‚ùå Error sending through sink for {}: {}",
                client.session.id, e.message, e)
            unregister(client.session.id)
        }
    }

    fun getConnectedClientsCount(): Int = clients.size
}
//
package ru.sber.poirot.notifications.websocket

import kotlinx.coroutines.reactor.mono
import org.springframework.web.reactive.socket.WebSocketHandler
import org.springframework.web.reactive.socket.WebSocketSession
import org.springframework.web.reactive.socket.WebSocketMessage
import reactor.core.publisher.Mono
import reactor.core.publisher.Flux
import reactor.core.publisher.Sinks
import ru.sber.parseJson
import ru.sber.poirot.notifications.admin.AdminNotifications
import ru.sber.poirot.notifications.admin.dto.FeedResponse
import ru.sber.poirot.notifications.admin.dto.WsMessage
import ru.sber.toJson
import ru.sber.utils.logger
import java.time.Duration
import java.util.concurrent.atomic.AtomicLong

class FeedWebSocketHandler(
    private val adminNotifications: AdminNotifications
) : WebSocketHandler {

    private val log = logger()

    override fun handle(session: WebSocketSession): Mono<Void> {
        log.info("New WS connection: {}", session.id)
        val lastSeen = AtomicLong(System.currentTimeMillis())

        val receiveFlux = session.receive()
            .flatMap { msg ->
                lastSeen.set(System.currentTimeMillis())
                val payload = msg.payloadAsText

                try {
                    val wsMessage = payload.parseJson<WsMessage>()

                    when (wsMessage.type) {
                        WsMessage.Type.PING -> {
                            log.debug("Received PING from {}", session.id)
                            Mono.empty<Void>()
                        }

                        WsMessage.Type.SUBSCRIBE -> {
                            log.info("Processing SUBSCRIBE for session {}", session.id)

                            // 1Ô∏è‚É£ –ü–æ–ª—É—á–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                            mono {
                                val (feed, roleIds) = try {
                                    adminNotifications.feed()
                                } catch (e: Exception) {
                                    log.error("Failed to get feed for {}: {}", session.id, e.message, e)
                                    val errorMsg = WsMessage.error("Authentication failed: ${e.message}")
                                    session.send(Mono.just(session.textMessage(errorMsg.toJson()))).subscribe()
                                    return@mono Pair(emptyList<FeedResponse>(), emptySet<Int>())
                                }

                                log.info("Subscribed session {} with roles: {}, feed size: {}",
                                    session.id, roleIds, feed.size)

                                Pair(feed, roleIds)
                            }.flatMapMany { (feed, roleIds) ->

                                // 2Ô∏è‚É£ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                                val initial = if (feed.isNotEmpty()) {
                                    val msgText = WsMessage.data(feed).toJson()
                                    session.send(Mono.just(session.textMessage(msgText)))
                                } else {
                                    Mono.empty<Void>()
                                }

                                // 3Ô∏è‚É£ –°–æ–∑–¥–∞–µ–º –ø–æ—Ç–æ–∫ –¥–ª—è broadcast —Å–æ–±—ã—Ç–∏–π
                                val live = Flux.create<List<FeedResponse>> { sink ->
                                    // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º sink –≤ BroadcastRegistry
                                    BroadcastRegistry.register(session.id, session, roleIds, feed.toMutableList(), sink)
                                }

                                // 4Ô∏è‚É£ –û–±—ä–µ–¥–∏–Ω—è–µ–º: —Å–Ω–∞—á–∞–ª–∞ initial, –ø–æ—Ç–æ–º live —Å–æ–±—ã—Ç–∏—è
                                Flux.concat(
                                    initial.then(Mono.empty<WebSocketMessage>()),
                                    live.flatMap { feedList ->
                                        val msg = WsMessage.data(feedList).toJson()
                                        session.send(Mono.just(session.textMessage(msg)))
                                    }
                                )
                            }
                        }

                        else -> {
                            log.warn("Unknown WSMessage type: {} from {}", wsMessage.type, session.id)
                            val err = WsMessage.error("Unknown WSMessage type: ${wsMessage.type}")
                            session.send(Mono.just(session.textMessage(err.toJson()))).then()
                        }
                    }
                } catch (e: Exception) {
                    log.error("WS processing error for {}: {}", session.id, e.message, e)
                    val errorMsg = WsMessage.error("Invalid WSMessage: ${e.message}")
                    session.send(Mono.just(session.textMessage(errorMsg.toJson()))).then()
                }
            }
            .doFinally { signal ->
                log.info("Closing WS connection: {} by signal: {}", session.id, signal)
                BroadcastRegistry.unregister(session.id)
            }

        // Heartbeat
        val heartbeatFlux = heartbeat(lastSeen, session)

        return Flux.merge(receiveFlux, heartbeatFlux).then()
    }

    private fun heartbeat(lastSeen: AtomicLong, session: WebSocketSession): Flux<WebSocketMessage> =
        Flux.interval(Duration.ofSeconds(30))
            .flatMap {
                val now = System.currentTimeMillis()
                val timeSinceLastSeen = now - lastSeen.get()

                if (timeSinceLastSeen >= 90_000) {
                    log.warn("Session {} timed out (no activity for {}ms). Closing.",
                        session.id, timeSinceLastSeen)
                    BroadcastRegistry.unregister(session.id)
                    session.close().subscribe()
                    Mono.empty<WebSocketMessage>()
                } else {
                    log.debug("Sending PING to session {}", session.id)
                    val ping = session.textMessage(WsMessage.ping().toJson())
                    session.send(Mono.just(ping))
                        .doOnError { e ->
                            log.warn("Failed to send ping to {}: {}", session.id, e.message)
                            BroadcastRegistry.unregister(session.id)
                            session.close().subscribe()
                        }
                        .subscribe()
                    Mono.just(ping)
                }
            }
}
//
package ru.sber.poirot.notifications.websocket

import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Component
import ru.sber.poirot.notifications.websocket.BroadcastRegistry.getConnectedClientsCount
import ru.sber.utils.logger

@Component
class NotificationSyncScheduler {

    private val log = logger()

    @Scheduled(fixedDelay = 60000, initialDelay = 60000)
    fun checkExpiredNotifications() {
        try {
            val clientsCount = getConnectedClientsCount()

            if (clientsCount == 0) {
                return
            }

            val hasExpired = BroadcastRegistry.hasExpiredNotifications()

            if (!hasExpired) {
                log.debug("‚úÖ No expired notifications in memory")
                return
            }

            log.info("‚è∞ Found expired notifications, refreshing {} clients", clientsCount)

            BroadcastRegistry.refreshAll()

        } catch (e: Exception) {
            log.error("‚ùå Error checking expired notifications: {}", e.message, e)
        }
    }
}
//
package ru.sber.poirot.notifications.websocket

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.web.reactive.HandlerMapping
import org.springframework.web.reactive.handler.SimpleUrlHandlerMapping
import org.springframework.web.reactive.socket.server.support.WebSocketHandlerAdapter
import ru.sber.poirot.notifications.admin.AdminNotifications

@Configuration
class WebSocketConfig {

    @Bean
    fun feedWebSocketHandler(
        adminNotifications: AdminNotifications
    ): FeedWebSocketHandler = FeedWebSocketHandler(adminNotifications)

    @Bean
    fun webSocketHandlerMapping(feedWebSocketHandler: FeedWebSocketHandler): HandlerMapping {
        val map = mapOf("/ws/feed" to feedWebSocketHandler)
        return SimpleUrlHandlerMapping(map, -1)
    }

    @Bean
    fun handlerAdapter() = WebSocketHandlerAdapter()
}
//
package ru.sber.poirot.notifications.kafka

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.stereotype.Component
import ru.sber.kafka.producer.MetricsKafkaProducer
import ru.sber.utils.logger

@Component
@ConditionalOnProperty(value = ["spring.kafka.producer.notification.enable"], havingValue = "true")
class NotificationProducer(
    private val kafkaProducer: MetricsKafkaProducer<String, NotificationEvent>
) {
    private val log = logger()

    suspend fun sendEvent(event: NotificationEvent) {
        try {
            log.info("üì§ Sending notification event to Kafka: type={}, id={}",
                event.type, event.notificationId)

            kafkaProducer.send(
                event = event,
                key = event.notificationId.toString(),
                onCompleteAlways = { e, throwable ->
                    if (throwable != null) {
                        log.error("‚ùå Failed to send notification event to Kafka: {}",
                            throwable.message, throwable)
                    } else {
                        log.debug("‚úÖ Notification event sent to Kafka: type={}, id={}",
                            e.type, e.notificationId)
                    }
                }
            )
        } catch (e: Exception) {
            log.error("‚ùå Error sending notification event to Kafka: {}", e.message, e)
        }
    }

    suspend fun sendCreated(notificationId: Long) {
        sendEvent(NotificationEvent(NotificationEvent.EventType.CREATED, notificationId))
    }

    suspend fun sendUpdated(notificationId: Long) {
        sendEvent(NotificationEvent(NotificationEvent.EventType.UPDATED, notificationId))
    }

    suspend fun sendArchived(notificationId: Long) {
        sendEvent(NotificationEvent(NotificationEvent.EventType.ARCHIVED, notificationId))
    }
}
//
package ru.sber.poirot.notifications.kafka

import ru.sber.poirot.engine.ds.refreshable.Delayer
import ru.sber.poirot.engine.ds.refreshable.delayers.channel.ChannelDelayerFactory.kafkaDelayer
import ru.sber.poirot.engine.ds.refreshable.delayers.kafka.kafkaTriggerNames
import ru.sber.poirot.notifications.common.metamodel.adminNotification

object NotificationKafkaDelayer {

    fun notificationKafkaDelayer(refreshableName: String): Delayer =
        kafkaDelayer(
            refreshableName = refreshableName,
            triggerNames = listOf(adminNotification).kafkaTriggerNames(),
            forceUpdateEveryMin = 3,
        )
}
//
package ru.sber.poirot.notifications.kafka

import com.fasterxml.jackson.databind.ObjectMapper
import io.micrometer.core.instrument.MeterRegistry
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.annotation.Primary
import org.springframework.kafka.core.KafkaTemplate
import ru.sber.kafka.producer.KafkaProducerImpl
import ru.sber.kafka.producer.MetricsKafkaProducer

@Configuration
class NotificationKafkaConfig(
    objectMapper: ObjectMapper
) {

    private val prettyWriter = objectMapper.writerWithDefaultPrettyPrinter()

    @Bean
    fun notificationKafkaProducerImpl(
        kafkaTemplate: KafkaTemplate<String?, String>,
        @Value("\${kafka.producer.topic:}")
        topic: String
    ): KafkaProducerImpl<String, NotificationEvent> = KafkaProducerImpl(
        template = kafkaTemplate,
        topic = topic,
        eventGetter = { prettyWriter.writeValueAsString(this) }
    )

    @Bean
    @Primary
    fun notificationMetricsKafkaProducer(
        meterRegistry: MeterRegistry,
        notificationKafkaProducerImpl: KafkaProducerImpl<String, NotificationEvent>
    ): MetricsKafkaProducer<String, NotificationEvent> = MetricsKafkaProducer(
        meterRegistry = meterRegistry,
        delegate = notificationKafkaProducerImpl
    )
}
//
package ru.sber.poirot.notifications.kafka

import com.fasterxml.jackson.annotation.JsonFormat
import java.time.LocalDateTime

data class NotificationEvent(
    val type: EventType,
    val notificationId: Long,
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss")
    val timestamp: LocalDateTime = LocalDateTime.now()
) {
    enum class EventType {
        CREATED,
        UPDATED,
        ARCHIVED
    }
}
//
package ru.sber.poirot.notifications.kafka

import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.apache.kafka.clients.consumer.ConsumerRecord
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.kafka.annotation.KafkaListener
import org.springframework.kafka.support.Acknowledgment
import org.springframework.stereotype.Component
import ru.sber.parseJson
import ru.sber.poirot.notifications.admin.dto.toFeedResponse
import ru.sber.poirot.notifications.admin.impl.AdminNotificationsDao
import ru.sber.poirot.notifications.websocket.BroadcastRegistry
import ru.sber.utils.logger

@Component
@ConditionalOnProperty(value = ["spring.kafka.consumer.notification.enable"], havingValue = "true")
class NotificationConsumer(
    private val adminNotificationsDao: AdminNotificationsDao
) {
    private val log = logger()
    private val scope = CoroutineScope(Dispatchers.Default)

    @KafkaListener(
        topics = ["\${kafka.consumer.topic}"],
        groupId = "\${spring.kafka.consumer.group-id}"
    )
    fun consumeNotificationEvent(
        record: ConsumerRecord<String, String>,
        acknowledgment: Acknowledgment
    ) {
        scope.launch {
            try {
                val event = record.value().parseJson<NotificationEvent>()

                log.info("üì® Received notification event from Kafka: type={}, id={}",
                    event.type, event.notificationId)

                when (event.type) {
                    NotificationEvent.EventType.CREATED,
                    NotificationEvent.EventType.UPDATED -> {
                        handleCreatedOrUpdated(event.notificationId)
                    }
                    NotificationEvent.EventType.ARCHIVED -> {
                        handleArchived(event.notificationId)
                    }
                }

                acknowledgment.acknowledge()

            } catch (e: Exception) {
                log.error("‚ùå Error processing notification event from Kafka: {}", e.message, e)
            }
        }
    }

    private suspend fun handleCreatedOrUpdated(notificationId: Long) {
        try {
            val notification = adminNotificationsDao.fetchById(notificationId)
            val feedResponse = notification.toFeedResponse()

            log.info("üì¢ Broadcasting notification {} clients on this pod",
                notificationId)

            BroadcastRegistry.publish(listOf(feedResponse))

        } catch (e: Exception) {
            log.warn("‚ö†Ô∏è Notification {} not found or not accessible: {}",
                notificationId, e.message)
        }
    }

    private suspend fun handleArchived(notificationId: Long) {
        log.info("üì¢ Broadcasting archived notification {} clients on this pod",
            notificationId)

        BroadcastRegistry.removeNotification(notificationId)
    }
}
//
package ru.sber.poirot.notifications.admin.impl

import org.springframework.stereotype.Repository
import ru.sber.poirot.engine.datasources.PoirotDatabaseNames.POIROT_USERS
import ru.sber.poirot.engine.datasources.transaction.TransactionTemplates
import ru.sber.poirot.engine.ds.refreshable.RefreshableSet
import ru.sber.poirot.engine.ds.refreshable.buildRefreshableSet
import ru.sber.poirot.engine.ds.refreshable.refreshableBuilder
import ru.sber.poirot.engine.dsl.Order.DESC
import ru.sber.poirot.engine.dsl.existsAny
import ru.sber.poirot.engine.dsl.findAll
import ru.sber.poirot.engine.dsl.findFirst
import ru.sber.poirot.exception.FrontException
import ru.sber.poirot.notifications.admin.impl.DslAdminNotificationsDao.FeedableHolder.feedable
import ru.sber.poirot.notifications.common.entity.AdminNotification
import ru.sber.poirot.notifications.common.error.NotificationErrorCode.NOTIFICATION_NOT_FOUND
import ru.sber.poirot.notifications.common.metamodel.adminNotification
import ru.sber.poirot.notifications.kafka.NotificationKafkaDelayer.notificationKafkaDelayer
import ru.sber.poirot.refreshable.InitRefreshables
import ru.sber.poirot.utils.inTransactionWithReactorContext
import ru.sber.sql.persister.AsyncGraphPersister
import java.time.LocalDateTime.now

@Repository
class DslAdminNotificationsDao(
    private val persister: AsyncGraphPersister,
    templates: TransactionTemplates
) : AdminNotificationsDao {
    private val pkapTemplate = templates[POIROT_USERS]

    @InitRefreshables
    private object FeedableHolder {

        val feedable: RefreshableSet<AdminNotification> =
            refreshableBuilder("NOTIFICATION_FEED") {
                delayer = notificationKafkaDelayer(name)
            }.buildRefreshableSet {
                findAll(
                    entity = adminNotification,
                    order = DESC,
                    orderBy = listOf(adminNotification.lastModified),
                    batch = false
                ) fetchFields {
                    allFieldsWithRelations
                } where {
                    val now = now()
                    dateFrom lessThanOrEqualTo now
                    dateTo greaterThanOrEqualTo now
                    archive `=` false
                    publish `=` true
                }
            }
    }

    override suspend fun insert(adminNotification: AdminNotification) {
        adminNotification.apply { persister.insert(listOf(adminNotification)) }
    }

    override suspend fun merge(adminNotification: AdminNotification) {
        pkapTemplate.inTransactionWithReactorContext {
            adminNotification.apply { persister.merge(listOf(adminNotification)) }
        }
    }

    override suspend fun fetchById(notificationId: Long): AdminNotification =
        (findFirst(entity = adminNotification, batch = false) fetchFields {
            allFieldsWithRelations
        } where {
            id `=` notificationId
        }) ?: throw FrontException(NOTIFICATION_NOT_FOUND)

    override suspend fun existsNotArchivedWithId(notificationId: Long): Boolean =
        existsAny(adminNotification, batch = false) where {
            id `=` notificationId
            archive `=` false
        }

    override suspend fun fetchAll(): List<AdminNotification> =
        findAll(entity = adminNotification, batch = false) fetchFields {
            allFieldsWithRelations
        } where {
            archive `=` false
        }

    override suspend fun feed(userRoleIds: Set<Int>): List<AdminNotification> {
        val res = feedable.asSet()
            .filterNot { it.mapping.isNullOrEmpty() }
            .filter { it.mapping.any { mapp -> userRoleIds.contains(mapp.roleId) } }

        return when {
            res.size > 3 -> res.slice(0..2)
            else -> res
        }
    }

    override suspend fun feedAll(): List<AdminNotification> =
        feedable.asSet().toList()
}
//
package ru.sber.poirot.notifications.admin.impl

import org.springframework.stereotype.Service
import ru.sber.poirot.CurrentUser
import ru.sber.poirot.exception.FrontException
import ru.sber.poirot.notifications.admin.AdminNotifications
import ru.sber.poirot.notifications.admin.dto.*
import ru.sber.poirot.notifications.common.error.NotificationErrorCode.NOTIFICATION_NOT_FOUND_OR_ARCHIVED
import ru.sber.poirot.notifications.kafka.NotificationProducer
import ru.sber.poirot.notifications.roles.RolesDao

@Service
class AdminNotificationsImpl(
    private val adminNotificationsDao: AdminNotificationsDao,
    private val rolesDao: RolesDao,
    private val currentUser: CurrentUser,
    private val notificationProducer: NotificationProducer?
) : AdminNotifications {

    override suspend fun create(request: CreateRequest): NotificationResponse {
        val newRoleIds = chooseRoleIds(request.roleIds)
        val notification = request.adminNotification(currentUser.userName(), newRoleIds)
        adminNotificationsDao.insert(notification)

        notificationProducer?.sendCreated(notification.id)
        return notification.notificationResponse()
    }

    override suspend fun update(request: UpdateRequest) {
        if (!adminNotificationsDao.existsNotArchivedWithId(request.id)) {
            throw FrontException(NOTIFICATION_NOT_FOUND_OR_ARCHIVED)
        }

        val notification = request.adminNotification(chooseRoleIds(request.roleIds))
        adminNotificationsDao.merge(notification)

        notificationProducer?.sendUpdated(notification.id)
    }

    override suspend fun archive(id: Long) {
        val notification = adminNotificationsDao.fetchById(id).apply { archive = true }
        adminNotificationsDao.merge(notification)

        notificationProducer?.sendArchived(notification.id)
    }

    override suspend fun feed(): Pair<List<FeedResponse>, Set<Int>> {
        val userRoleIds = currentUser.rolesIds().toSet()
        val feed = adminNotificationsDao.feed(userRoleIds).map { it.toFeedResponse() }
        return feed to userRoleIds
    }

    override suspend fun fetchAll(): List<NotificationResponse> =
        adminNotificationsDao.fetchAll().map { it.notificationResponse() }

    private suspend fun chooseRoleIds(roleIds: List<Int>?): List<Int> = when {
        roleIds.isNullOrEmpty() -> rolesDao.getAllRoleIds()
        else -> roleIds
    }
}
//
package ru.sber.poirot.notifications.admin

import org.springframework.security.access.prepost.PreAuthorize
import org.springframework.web.bind.annotation.*
import ru.sber.permissions.HAS_MANAGE_NOTIFICATIONS
import ru.sber.poirot.audit.AuditClient
import ru.sber.poirot.notifications.admin.dto.CreateRequest
import ru.sber.poirot.notifications.admin.dto.NotificationResponse
import ru.sber.poirot.notifications.admin.dto.UpdateRequest

@RestController
@RequestMapping("/api/adminNotification")
class AdminNotificationController(
    private val service: AdminNotifications,
    private val auditClient: AuditClient
) {

    @PostMapping("/create")
    @PreAuthorize(HAS_MANAGE_NOTIFICATIONS)
    suspend fun create(@RequestBody request: CreateRequest): NotificationResponse =
        auditClient.audit(event = "NOTIFICATION_CREATE", details = "request=$request") {
            service.create(request)
        }

    @PutMapping("/update")
    @PreAuthorize(HAS_MANAGE_NOTIFICATIONS)
    suspend fun update(@RequestBody request: UpdateRequest): Unit =
        auditClient.audit(event = "NOTIFICATION_UPDATE", details = "request=$request") {
            service.update(request)
        }

    @DeleteMapping("/archive/{id}")
    @PreAuthorize(HAS_MANAGE_NOTIFICATIONS)
    suspend fun archive(@PathVariable id: Long): Unit =
        auditClient.audit(event = "NOTIFICATION_ARCHIVE", details = "id=$id") {
            service.archive(id)
        }

    @GetMapping("/fetchAll")
    @PreAuthorize(HAS_MANAGE_NOTIFICATIONS)
    suspend fun fetchAll(): List<NotificationResponse> =
        auditClient.audit(event = "NOTIFICATION_FETCH_ALL") {
            service.fetchAll()
        }
}
–í–æ–æ–±—â–µ–º –≤ —á–µ–º —Å—É—Ç—å —ç—Ç–æ –º–æ–π –∫–æ–¥ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π —Ç–µ–∫—É—â–∏–π –æ–Ω —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ. –ò–∑–Ω–∞—á–∞–ª—å–∞–Ω–æ –±—ã–ª–∞ –ø—Ä–æ–±–ª–µ–º–∞ —á—Ç–æ —É –º–µ–Ω—è –¥–≤–∞ –ø–ª–µ—á–∞ –∏ –ø–æ–¥–∞ –∏ –µ—Å–ª–∏ –Ω–∞ –æ–¥–Ω–æ –ø–ª–µ—á–æ –ø–æ–¥–∫–ª—é—á–∞–µ—Ç—Å—è —Å–æ–∫–µ—Ç –∞ –Ω–∞–¥—Ä–æ—É–≥–æ–º –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∑–∞–ø–∏—Å–∏ –∏ –æ–Ω–æ –¥–æ–ª–∂–Ω–∞ –ø—Ä–æ–ø–∞—Å—Ç—å —Ç–æ –≤—Ç–æ—Ä–æ –ø–ª–µ—á–æ –æ–±—ç—Ç–æ–º –Ω–µ –∑–Ω–∞–µ—Ç, —è –µ–µ —Ä–µ—à–∏–ª —Å–æ–∑–¥–∞–≤ —Å–≤–æ–π —Ç–æ–ø–∏–∫ NOTIFICATION_UPDATES –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–∏ –∫–∞–∂–¥–æ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ–¥—Ç—è–≥–∏–≤–∞–µ—Ç –∏–∑ –∫–∞—Ñ–∫–∏ –∏–Ω—Ñ—É. –î–∞–ª—å—à–µ –ø–æ—è–≤–∏–ª–æ—Å—å –ø—Ä–æ–±–ª–µ–º–∞ —á—Ç–æ –ø—Ä–∏ –ø–æ–¥–ø–∏—Å–∫–µ –Ω–∞ —Å–æ–∫–µ—Ç –æ–Ω –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–Ω—Ñ—É –∏–∑ –∫—ç—à–µ –Ω–∞ —Ç–æ—Ç –º–æ–º–µ–Ω—Ç –∫—ç—à –æ–±–Ω–æ–≤–ª—è–ª—Å—è –≤ —Ä–∞–∑ –º–∏–Ω—É—Ç—É –∏ –ø–æ–ª—É—á–∞–ª–æ—Å—å —Ç–∞–∫ —á—Ç–æ –ø—Ä–∏—Ö–æ–¥–∏–ª–∏ —Å—Ç–∞—Ä—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∏–∑ –Ω–µ–≥–æ, —á—Ç–æ–±—ã —ç—Ç–æ –∏—Å–ø—Ä–∞–≤–∏—Ç—å —è —Ä–µ—à–∏–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å delayer –¥–ª—è –∫–∞—Ñ–∫–∏ –Ω–æ –æ–∫–∞–∑–∞–ª–æ—Å—å —á—Ç–æ –æ–Ω —Ä–∞–±–æ—Ç–∞—Ç–µ —Ç–æ–ª—å–∫–æ —Å –±–∞–∑–æ–≤—ã–º –∫–æ–Ω—Ñ–∏–≥–æ–º –∫–∞—Ñ–∫–∏ –±–µ–∑ –º–æ–µ–π –ø—Ä–∏–ø–∏—Å–∫–∏ notifications (delayer'—ã –∏–∑ –º–æ–¥—É–ª—è refreshable —Ä–∞–±–æ—Ç–∞—é—Ç —Ç–æ–ª—å–∫–æ —Å –æ—Å–Ω–æ–≤–Ω—ã–º –∫–æ–Ω—Ñ–∏–≥–æ–º –∫–∞—Ñ–∫–∏ (kafkaCacheKeeperListener)
–µ—Å–ª–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ –ø–æ–º–Ω—é, —Ç–æ –≤ —Ç–≤–æ–µ–π –∑–∞–¥–∞—á–µ –¥–æ–≥–æ–≤–æ—Ä–∏–ª–∏—Å—å enable —Å –ø—Ä–µ—Ñ–∏–∫—Å–æ–º –¥–µ–ª–∞—Ç—å
–µ—Å–ª–∏ —Ç–µ–±–µ –Ω—É–∂–µ–Ω —Ç–æ–ø–∏–∫ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫—ç—à–∞, —Ç–æ –Ω—É–∂–Ω–æ –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å kafkaCacheKeeperListener –∏ –µ–≥–æ –∫–æ–Ω—Ñ–∏–≥ –±–µ–∑ –ø—Ä–µ—Ñ–∏–∫—Å–∞). –¢–µ–ø–µ—Ä—å —è –¥—É–º–∞—é —á—Ç–æ –º–Ω–µ —Å —ç—Ç–∏–º –≤—Å–µ–º –¥–µ–ª–∞—Ç—å, –µ—Å–ª–∏ —è —Å–¥–ª–∞—é –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫—ç—à–µ —á–µ—Ä–µ–∑ –æ—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Ñ–∏–≥ –∏ —Å—Ç–∞—Ä—ã–π —Ç–æ–ø–∏–∫, —Ç–æ –≤ —Ü–µ–ª–æ–º –º–Ω–µ –Ω–Ω—É–∂–Ω–æ –±—É–¥–µ—Ç —á—Ç–æ–± –Ω–æ–≤—ã–µ –∑–∞–ø–∏—Å–∏ –µ—à–µ —Ä–∞—Å—Å—ã–ª–∞–ª–∏—Å—å –≤ –∫–∞–∂–¥—ã–π —Å–æ–∫–µ—Ç –∏ –º–Ω–µ –Ω—É–∂–µ–Ω —ç—Ç–æ—Ç —Ç–æ–ø–∏–∫ NOTIFICATION_UPDATES, –∫–æ—Ä–æ—á–µ –∫–∞–∫ —ç—Ç–æ —Å–¥–µ–ª–∞—Ç—å. –î–∞–ª—å—à–µ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ –º–æ–≥—É —Å–∫–∏–Ω—É—Ç—å –∫–æ–Ω—Ñ–∏–≥ 
