package ru.sber.poirot.notifications.kafka

import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.apache.kafka.clients.consumer.ConsumerRecord
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.kafka.annotation.KafkaListener
import org.springframework.stereotype.Component
import ru.sber.parseJson
import ru.sber.poirot.engine.ds.refreshable.delayers.kafka.KafkaUpdateEvent
import ru.sber.poirot.notifications.admin.dto.toFeedResponse
import ru.sber.poirot.notifications.admin.impl.AdminNotificationsDao
import ru.sber.poirot.notifications.websocket.BroadcastRegistry
import ru.sber.utils.logger

@Component
@ConditionalOnProperty(value = ["spring.kafka.consumer.notification.enable"], havingValue = "true")
class WebSocketCacheConsumer(
    private val adminNotificationsDao: AdminNotificationsDao
) {
    private val log = logger()
    private val scope = CoroutineScope(Dispatchers.Default)

    @KafkaListener(
        topics = ["\${spring.kafka.topic}"],
        groupId = "\${spring.kafka.consumer.group-id}"
    )
    fun consumeNotificationEvent(
        record: ConsumerRecord<String, String>
    ) {
        scope.launch {
            try {
                val notificationId = record.key().toLongOrNull()
                val event = record.value().parseJson<KafkaUpdateEvent>()

                log.info("üì® Received cache update for WebSocket: id={}", notificationId)

                if (notificationId == null) {
                    log.warn("‚ö†Ô∏è Invalid notification ID in event: {}", event.uuid)
                    return@launch
                }

                processNotification(notificationId)

            } catch (e: Exception) {
                log.error("‚ùå Error processing cache update: {}", e.message, e)
            }
        }
    }

    private suspend fun processNotification(notificationId: Long) {
        try {
            val notification = adminNotificationsDao.fetchById(notificationId)

            if (notification.archive) {
                log.info("üóëÔ∏è Notification {} is archived, removing from clients", notificationId)
                BroadcastRegistry.removeNotification(notificationId)
            } else {
                val feedResponse = notification.toFeedResponse()
                log.info("üì¢ Broadcasting notification {} to clients (archive={})",
                    notificationId, notification.archive)
                BroadcastRegistry.publish(listOf(feedResponse))
            }

        } catch (e: Exception) {
            log.error("‚ùå Error processing notification {}: {}", notificationId, e.message, e)
        }
    }
}
