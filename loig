package ru.sber.poirot.notifications.kafka

import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.apache.kafka.clients.consumer.ConsumerRecord
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.kafka.annotation.KafkaListener
import org.springframework.kafka.support.Acknowledgment
import org.springframework.stereotype.Component
import ru.sber.poirot.engine.ds.refreshable.delayers.kafka.KafkaDelayerReceptionist
import ru.sber.poirot.engine.ds.refreshable.delayers.kafka.KafkaUpdateEvent
import ru.sber.poirot.notifications.admin.AdminNotifications
import ru.sber.poirot.notifications.websocket.BroadcastRegistry
import ru.sber.poirot.utils.parseJson
import ru.sber.utils.logger
import java.time.LocalDateTime
import java.util.UUID

@Component
@ConditionalOnProperty(value = ["spring.kafka.consumer.notification.enable"], havingValue = "true")
class NotificationConsumer(
    private val adminNotifications: AdminNotifications
) {
    private val log = logger()
    private val scope = CoroutineScope(Dispatchers.Default)

    @KafkaListener(
        topics = ["\${kafka.consumer.topic}"],
        groupId = "\${spring.kafka.consumer.group-id}"
    )
    fun consumeNotificationEvent(
        record: ConsumerRecord<String, String>,
        acknowledgment: Acknowledgment
    ) {
        scope.launch {
            try {
                val event = record.value().parseJson<NotificationEvent>()
                val key = record.key() ?: ""

                log.info("üì® Received notification event from Kafka: type={}, id={}, key={}",
                    event.type, event.notificationId, key)

                // ‚úÖ –¢–†–ò–ì–ì–ï–†–ò–ú –û–ë–ù–û–í–õ–ï–ù–ò–ï –ö–ï–®–ê!
                if (key.isNotEmpty()) {
                    triggerCacheRefresh(key)
                }

                // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–±—ã—Ç–∏—è –¥–ª—è WebSocket
                when (event.type) {
                    NotificationEvent.EventType.CREATED,
                    NotificationEvent.EventType.UPDATED -> {
                        handleCreatedOrUpdated(event.notificationId)
                    }
                    NotificationEvent.EventType.ARCHIVED -> {
                        handleArchived(event.notificationId)
                    }
                }

                acknowledgment.acknowledge()

            } catch (e: Exception) {
                log.error("‚ùå Error processing notification event from Kafka: {}", e.message, e)
            }
        }
    }

    private suspend fun triggerCacheRefresh(key: String) {
        try {
            val delayers = KafkaDelayerReceptionist.get(key)
            
            if (delayers.isNotEmpty()) {
                val kafkaEvent = KafkaUpdateEvent(
                    id = UUID.randomUUID().toString(),
                    timestamp = LocalDateTime.now(),
                    triggerName = key
                )
                
                // ‚úÖ –ò–°–ü–û–õ–¨–ó–£–ï–ú offer() - —ç—Ç–æ suspend —Ñ—É–Ω–∫—Ü–∏—è!
                delayers.forEach { delayer ->
                    delayer.offer(kafkaEvent)
                }
                
                log.debug("üîÑ Triggered {} delayer(s) for key: {}", delayers.size, key)
            } else {
                log.debug("‚ö†Ô∏è No delayers registered for key: {}", key)
            }
        } catch (e: Exception) {
            log.warn("‚ö†Ô∏è Failed to trigger cache refresh for key {}: {}", key, e.message)
        }
    }

    private suspend fun handleCreatedOrUpdated(notificationId: Long) {
        try {
            val notification = adminNotifications.fetchById(notificationId)
            BroadcastRegistry.publish(notification)
            log.info("üì¢ Broadcasting notification {} to clients on this pod", notificationId)
        } catch (e: Exception) {
            log.error("‚ùå Error handling notification {}: {}", notificationId, e.message, e)
        }
    }

    private suspend fun handleArchived(notificationId: Long) {
        BroadcastRegistry.removeNotification(notificationId)
        log.info("üóëÔ∏è Removed notification {} from all clients", notificationId)
    }
}
