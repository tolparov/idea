package ru.sber.poirot.notifications.kafka

import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.apache.kafka.clients.consumer.ConsumerRecord
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.kafka.annotation.KafkaListener
import org.springframework.kafka.support.Acknowledgment
import org.springframework.stereotype.Component
import ru.sber.parseJson
import ru.sber.poirot.engine.ds.refreshable.delayers.kafka.KafkaUpdateEvent
import ru.sber.poirot.notifications.admin.dto.toFeedResponse
import ru.sber.poirot.notifications.admin.impl.AdminNotificationsDao
import ru.sber.poirot.notifications.websocket.BroadcastRegistry
import ru.sber.utils.logger

@Component
@ConditionalOnProperty(
    value = ["spring.kafka.consumer.notification.enable"], 
    havingValue = "true",
    matchIfMissing = false
)
class WebSocketCacheConsumer(
    private val adminNotificationsDao: AdminNotificationsDao
) {
    private val log = logger()
    private val scope = CoroutineScope(Dispatchers.Default)

    companion object {
        private const val TRIGGER_NAME = "admin_notifications"  // ‚Üê –ö–û–ù–°–¢–ê–ù–¢–ê!
    }

    @KafkaListener(
        topics = ["\${spring.kafka.topic}"],
        groupId = "\${spring.kafka.consumer.group-id}-websocket"
    )
    fun consumeNotificationEvent(
        record: ConsumerRecord<String, String>,
        acknowledgment: Acknowledgment
    ) {
        scope.launch {
            try {
                val event = record.value().parseJson<KafkaUpdateEvent>()
                
                // ‚úÖ –§–ò–õ–¨–¢–† –ü–û triggerName!
                if (event.triggerName != TRIGGER_NAME) {
                    log.debug("Skipping event with triggerName={}, expected={}", 
                        event.triggerName, TRIGGER_NAME)
                    acknowledgment.acknowledge()
                    return@launch
                }

                val notificationId = record.key().toLongOrNull()
                log.info("üì® Received cache update for WebSocket: id={}", notificationId)

                if (notificationId == null) {
                    log.warn("‚ö†Ô∏è Invalid notification ID in event: {}", event.uuid)
                    acknowledgment.acknowledge()
                    return@launch
                }

                processNotification(notificationId)
                
                acknowledgment.acknowledge()
                log.debug("‚úÖ Acknowledged message with id={}", notificationId)

            } catch (e: Exception) {
                log.error("‚ùå Error processing cache update: {}", e.message, e)
                acknowledgment.acknowledge()
            }
        }
    }

    private suspend fun processNotification(notificationId: Long) {
        try {
            val notification = adminNotificationsDao.fetchById(notificationId)
            
            if (notification == null) {
                log.info("üóëÔ∏è Notification {} not found, removing from clients", notificationId)
                BroadcastRegistry.removeNotification(notificationId)
                return
            }

            if (notification.archive) {
                log.info("üóëÔ∏è Notification {} is archived, removing from clients", notificationId)
                BroadcastRegistry.removeNotification(notificationId)
            } else {
                val feedResponse = notification.toFeedResponse()
                log.info("üì¢ Broadcasting notification {} to clients (archive={})", 
                    notificationId, notification.archive)
                BroadcastRegistry.publish(listOf(feedResponse))
            }

        } catch (e: Exception) {
            log.error("‚ùå Error processing notification {}: {}", notificationId, e.message, e)
        }
    }
}
