package ru.sber.poirot.notifications.kafka

import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.apache.kafka.clients.consumer.ConsumerRecord
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.kafka.annotation.KafkaListener
import org.springframework.stereotype.Component
import ru.sber.parseJson
import ru.sber.poirot.engine.ds.refreshable.delayers.kafka.KafkaUpdateEvent
import ru.sber.poirot.notifications.admin.dto.toFeedResponse
import ru.sber.poirot.notifications.admin.impl.AdminNotificationsDao
import ru.sber.poirot.notifications.websocket.BroadcastRegistry
import ru.sber.utils.logger

@Component
@ConditionalOnProperty(value = ["spring.kafka.consumer.enable"], havingValue = "true")
class WebSocketCacheConsumer(
    private val adminNotificationsDao: AdminNotificationsDao
) {
    private val log = logger()
    private val scope = CoroutineScope(Dispatchers.Default)

    @KafkaListener(
        topics = ["\${spring.kafka.topic:}"],
        groupId = "\${spring.kafka.consumer.group-id}"
    )
    fun consumeNotificationEvent(
        record: ConsumerRecord<String, String>
    ) {
        scope.launch {
            try {
                val event = record.value().parseJson<KafkaUpdateEvent>()

                log.info("üì® Received notification event from Kafka: id={}",
                    event.uuid)

                when (event.type) {
                    NotificationEvent.EventType.CREATED,
                    NotificationEvent.EventType.UPDATED -> {
                        handleCreatedOrUpdated(event.uuid.toLong())
                    }
                    NotificationEvent.EventType.ARCHIVED -> {
                        handleArchived(event.uuid.toLong())
                    }
                }
            } catch (e: Exception) {
                log.error("‚ùå Error processing notification event from Kafka: {}", e.message, e)
            }
        }
    }

    private suspend fun handleCreatedOrUpdated(notificationId: Long) {
        try {
            val notification = adminNotificationsDao.fetchById(notificationId)
            val feedResponse = notification.toFeedResponse()

            log.info("üì¢ Broadcasting notification {} clients on this pod",
                notificationId)

            BroadcastRegistry.publish(listOf(feedResponse))

        } catch (e: Exception) {
            log.warn("‚ö†Ô∏è Notification {} not found or not accessible: {}",
                notificationId, e.message)
        }
    }

    private suspend fun handleArchived(notificationId: Long) {
        log.info("üì¢ Broadcasting archived notification {} clients on this pod",
            notificationId)

        BroadcastRegistry.removeNotification(notificationId)
    }
}
