package ru.sber.poirot.notifications.kafka

import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.apache.kafka.clients.consumer.ConsumerRecord
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.kafka.annotation.KafkaListener
import org.springframework.stereotype.Component
import ru.sber.parseJson
import ru.sber.poirot.engine.ds.refreshable.delayers.kafka.KafkaUpdateEvent
import ru.sber.poirot.notifications.admin.dto.toFeedResponse
import ru.sber.poirot.notifications.admin.impl.AdminNotificationsDao
import ru.sber.poirot.notifications.websocket.BroadcastRegistry
import ru.sber.utils.logger

@Component
@ConditionalOnProperty(value = ["spring.kafka.consumer.enable"], havingValue = "true")
class WebSocketCacheConsumer(
    private val adminNotificationsDao: AdminNotificationsDao
) {
    private val log = logger()
    private val scope = CoroutineScope(Dispatchers.Default)

    @KafkaListener(
        topics = ["\${spring.kafka.topic}"],
        groupId = "\${spring.kafka.consumer.group-id}-websocket"
    )
    fun consumeNotificationEvent(
        record: ConsumerRecord<String, String>
    ) {
        scope.launch {
            try {
                val notificationId = record.key().toLongOrNull()
                val event = record.value().parseJson<KafkaUpdateEvent>()
                
                log.info("üì® Received cache update for WebSocket: id={}", notificationId)

                if (notificationId == null) {
                    log.warn("‚ö†Ô∏è Invalid notification ID in event: {}", event.uuid)
                    return@launch
                }

                // –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–∑ –ë–î –∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –¥–µ–π—Å—Ç–≤–∏–µ –ø–æ —Å–æ—Å—Ç–æ—è–Ω–∏—é
                processNotification(notificationId)

            } catch (e: Exception) {
                log.error("‚ùå Error processing cache update: {}", e.message, e)
            }
        }
    }

    private suspend fun processNotification(notificationId: Long) {
        try {
            val notification = adminNotificationsDao.fetchById(notificationId)
            
            if (notification == null) {
                // –ù–µ –Ω–∞–π–¥–µ–Ω–æ ‚Üí —Å—á–∏—Ç–∞–µ–º —á—Ç–æ –∞—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞–Ω–æ/—É–¥–∞–ª–µ–Ω–æ
                log.info("üóëÔ∏è Notification {} not found, removing from clients", notificationId)
                BroadcastRegistry.removeNotification(notificationId)
                return
            }

            if (notification.archive) {
                // archive = true ‚Üí —É–¥–∞–ª—è–µ–º –∏–∑ WebSocket
                log.info("üóëÔ∏è Notification {} is archived, removing from clients", notificationId)
                BroadcastRegistry.removeNotification(notificationId)
            } else {
                // archive = false ‚Üí –∞–∫—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ WebSocket
                val feedResponse = notification.toFeedResponse()
                log.info("üì¢ Broadcasting notification {} to clients (archive={})", 
                    notificationId, notification.archive)
                BroadcastRegistry.publish(listOf(feedResponse))
            }

        } catch (e: Exception) {
            log.error("‚ùå Error processing notification {}: {}", notificationId, e.message, e)
        }
    }
}
